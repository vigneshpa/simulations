{"version":3,"file":"assets/main.js","mappings":"mBAEA,MAGMA,EAA0B,EAAIC,KAAKC,GADf,GAIpBC,GAFa,IAJA,GAMwCH,GAI3D,IAAII,EAAU,EACVC,EAAM,EAEV,MAAMC,EAAaC,SAASC,kBAAkB,WAAW,GACzDF,EAAWG,IAVQ,GAWnBH,EAAWI,KAXQ,GAYnB,MAAMC,EAAQJ,SAASK,eAAe,gBACtCC,OAAOC,UAAaC,IAClBX,GAAWW,EACXJ,EAAMK,YAAcD,GAAKE,QAAQ,IAEnC,MAAMC,EAAQX,SAASK,eAAe,gBAEhCO,EAASZ,SAASK,eAAe,cACvCO,EAAOV,IAAMW,EAEb,MAAMC,EAAUd,SAASK,eAAe,YACxC,IAAIU,EAAiB,EAEjBC,EAAmD,YAGnDC,EAA0B,EAG1BC,EAAkC,KAClCC,GAAwB,EAC5Bb,OAAOc,eAAiBC,IACtBH,EAAmB,KACnBD,EAAkB,EAClBnB,EAAM,EACNqB,IAAiBE,EACbF,GAA6B,uBAAbH,IAAmCC,EAAkBrB,IAI3E,MAAM0B,EAA4BC,GAAkB1B,EA7CjC,EAgDb2B,EAA4BD,GAAmBN,GAAoBM,EAAQ1B,EAjD9D,GAoDb4B,EAA0BF,GAAmBN,GAAoBM,GAAS1B,EAnD7D,EAmDuEoB,GApDvE,GAsDnB,IAAIS,EAAmBJ,EAEvBhB,OAAOqB,cAAgBC,IAIrB,OAHAX,EAAkB,EAClBD,EAAWY,EACPT,GAAcb,OAAOc,gBAAe,GAChCQ,GACN,IAAK,YACHF,EAAmBJ,EACnB,MACF,IAAK,YACHI,EAAmBF,EACnB,MACF,IAAK,SACHE,EAAmBD,EACnB,MACF,IAAK,qBACHC,EAAmBF,EACnB,MACF,QACEE,EAAmBJ,IAIzB,IAAIO,EAAqB,EACzB,MAAMC,EAA6BC,IACjC,MAAMR,GAASQ,EAAYF,GAAc,IAEnCG,EAAUN,EAAiBH,GAEjCzB,EA5EkC,EA4EEkC,EAEpCjB,GAAUjB,EAAMyB,EAAQ,IACpBR,GAAU,KAAQA,EAAS,MAAMA,GAAkB,KACvDD,EAAQmB,MAAMC,UAAY,UAAUnB,QAGpCJ,EAAMF,UAAYuB,EAAQtB,QAAQ,GAClCE,EAAOuB,MAAQH,EAvFE,EAwFZd,IAAkBA,EAAmBa,GACtCZ,IACIf,EAAOK,WAAmBV,EAAYoC,MAAQtC,EA3FrC,GA4FAH,KAAK0C,KAAML,EAAYb,GAAoBzB,EAA2B,MAAOiB,QAAQ,IACtGmB,EAAaE,EACbzB,OAAO+B,sBAAsBP,IAE/BxB,OAAO+B,sBAAsBP,I","sources":["webpack://simulations/./src/inductorwheel/index.ts"],"sourcesContent":["import './style.scss'; // importing style sheet\n\nconst inductance = 10; // in Henries(H)\nconst resistance = 5; // in Ohms(Ω)\nconst sineWaveFrequency = 0.2; // in Hertz (Hz)\nconst sineWaveAngularVelocity = 2 * Math.PI * sineWaveFrequency; // in rad/sec as ω=2πf\nconst voltageMax = 10;\nconst currentMax = 2;\nconst initialInductorCurrent = -voltageMax / (inductance * sineWaveAngularVelocity); // as -I₀=-E₀/Lω\n\nconst angularVelocityCurrentRatio = 1;\n\nlet voltage = 0;\nlet rps = 0;\n\nconst voltageInp = document.getElementsByName('voltage')[0] as HTMLInputElement;\nvoltageInp.max = voltageMax as unknown as string;\nvoltageInp.min = -voltageMax as unknown as string;\nconst volEl = document.getElementById('voltageValue')!;\nwindow.onVoltage = (val: string) => {\n  voltage = +val;\n  volEl.innerText = (+val).toFixed(1);\n};\nconst curEl = document.getElementById('currentValue')!;\n\nconst curPgr = document.getElementById('currentPgr') as HTMLProgressElement;\ncurPgr.max = currentMax * 2;\n\nconst wheelEl = document.getElementById('flywheel')!;\nlet wheelR: number = 0;\n\nlet loadtype: Parameters<Window['onCircuitType']>[0] = 'Resistive';\n\n// Current integral for integration\nlet currentIntegral: number = 0;\n\n// Sine function generator\nlet generatorStartTS: number | null = null;\nlet generateSine: boolean = false;\nwindow.onGenerateSine = checked => {\n  generatorStartTS = null;\n  currentIntegral = 0;\n  rps = 0;\n  generateSine = !!checked;\n  if (generateSine && loadtype === 'InductiveCorrected') currentIntegral = initialInductorCurrent;\n};\n\n// Resistor function\nconst integrateResistorCurrent = (delta: number) => voltage / resistance; // as V=iR\n\n// Inductor function\nconst integrateInductorCurrent = (delta: number) => (currentIntegral += (delta * voltage) / inductance); // as V=-L(di/dt)\n\n// ResInd function\nconst integrateResIndCurrent = (delta: number) => (currentIntegral += (delta * (voltage - currentIntegral * resistance)) / inductance); // as V=-L(di/dt)+iR\n\nlet integrateCurrent = integrateResistorCurrent;\n\nwindow.onCircuitType = loadt => {\n  currentIntegral = 0;\n  loadtype = loadt;\n  if (generateSine) window.onGenerateSine(true);\n  switch (loadt) {\n    case 'Resistive':\n      integrateCurrent = integrateResistorCurrent;\n      break;\n    case 'Inductive':\n      integrateCurrent = integrateInductorCurrent;\n      break;\n    case 'ResInd':\n      integrateCurrent = integrateResIndCurrent;\n      break;\n    case 'InductiveCorrected':\n      integrateCurrent = integrateInductorCurrent;\n      break;\n    default:\n      integrateCurrent = integrateResistorCurrent;\n  }\n};\n\nlet previousTS: number = 0;\nconst step: FrameRequestCallback = timeStamp => {\n  const delta = (timeStamp - previousTS) / 1000; // calculating delta and converting it to seconds\n\n  const current = integrateCurrent(delta);\n\n  rps = angularVelocityCurrentRatio * current;\n\n  wheelR += rps * delta * 360;\n  if (wheelR > -5000 && wheelR < 5000) wheelR = wheelR % 360;\n  wheelEl.style.transform = `rotate(${wheelR}deg)`;\n\n  // --\n  curEl.innerText = current.toFixed(1);\n  curPgr.value = current + currentMax;\n  if (!generatorStartTS) generatorStartTS = timeStamp;\n  if (generateSine)\n    (<any>volEl).innerText = ((<any>voltageInp).value = voltage =\n      voltageMax * Math.sin(((timeStamp - generatorStartTS) * sineWaveAngularVelocity) / 1000)).toFixed(1);\n  previousTS = timeStamp;\n  window.requestAnimationFrame(step);\n};\nwindow.requestAnimationFrame(step);\n\ndeclare global {\n  interface Window {\n    onVoltage: (val: string) => void;\n    onCircuitType: (loadt: 'Resistive' | 'Inductive' | 'InductiveCorrected' | 'ResInd') => void;\n    onGenerateSine: (checked: boolean) => void;\n  }\n}\n"],"names":["sineWaveAngularVelocity","Math","PI","initialInductorCurrent","voltage","rps","voltageInp","document","getElementsByName","max","min","volEl","getElementById","window","onVoltage","val","innerText","toFixed","curEl","curPgr","currentMax","wheelEl","wheelR","loadtype","currentIntegral","generatorStartTS","generateSine","onGenerateSine","checked","integrateResistorCurrent","delta","integrateInductorCurrent","integrateResIndCurrent","integrateCurrent","onCircuitType","loadt","previousTS","step","timeStamp","current","style","transform","value","sin","requestAnimationFrame"],"sourceRoot":""}